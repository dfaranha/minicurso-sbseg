
\subsection{Ferramentas para verificação de tempo constante}

Os primeiros métodos para verificação formal de contramedidas para canais laterais de tempo foram construídos a partir de análise estática. \cite{MolnarPSW05} propõem métodos para detectar canais laterais de controle de fluxo e transformar código fonte em C para eliminar as vulnerabilidades, abrangendo ataques de tempo e tratamento de erros. \cite{CoppensVBS09} modificam um compilador para converter comandos condicionais de forma que o código \emph{Assembly} resultante não mais tenha comportamento no tempo dependente dos dados processados.
~\cite{LuxS11} propõem uma ferramenta para detectar potenciais canais laterais em implementações em Java de algoritmos criptográficos, baseados em anotações do programador. Em~\cite{KopfMO12}, os autores propõem um método novo baseado em limitantes superiores automaticamente derivados na quantidade de informação sobre a entrada que o adversário consegue extrair de um programa a partir da observação do comportamento da \emph{cache} durante a execução. \cite{DoychevKMR15} propõem métodos para calcular aproximações precisas da quantidade de informação vazada que podem ser observadas nos canais laterais a seguir: transições de estado na \emph{cache}, traços de acertos e erros, e tempo de execução. Os autores também sugerem provas formais de segurança para contramedidas
como pré-carga de endereços e padrão de acesso independente de dados.

Ainda considerando ataques de tempo, outras abordagens para verificação foram propostas recentemente. O trabalho~\cite{AlmeidaBPV13} considera as políticas em alto nível adotadas na implementação da biblioteca NaCl:
ausência de desvios condicionais e endereçamento de vetores dependentes de dados;
formalizam as políticas e propõem um método de verificação formal baseado em auto-composição,
demonstrando-o pela aplicação no código \emph{Assembly} otimizado de algumas funções da biblioteca.
\cite{Langley12} propõe um método de análise dinâmico baseado no módulo \texttt{memcheck} da ferramenta \emph{Valgrind}, que amplifica sua capacidade para
reconhecer dados não-inicializados na granularidade de \emph{bits}. A ferramenta \emph{FlowTracker}\footnote{\url{http://cuda.dcc.ufmg.br/flowtracker/}}~\cite{RodriguesPA16} foi proposta recentemente para verificar comportamento constante de código compilado pela análise estática de fluxo de informação na representação intermediária LLVM. As vantagens da ferramenta são a facilidade de descrição das interfaces e a baixa intrusão, já que nenhuma alteração é necessária no código. CT-Verif~\cite{AlmeidaBBDE16} é uma ferramenta seguindo uma abordagem similar que fornece garantias formais adicionais, mas exige alteração do código pelo verificador.

\subsection{Ferramentas para verificação de implementações contra ataques de potência}

%\subsubsection{Aplicação semi-automática de contramedidas}

%==================================================================================================
%% texto proposta projeto Intel-Fapesp "Secure execution of cryptographic algorithms" de 2014
%==================================================================================================

%Formal verification also has been applied to power analysis. Moss et al.~\cite{moss2011automatic} introduce an algorithm to  automate the process of application of masking countermeasures against DPA, at the assembly code level. 

%%% Formal verification of software implementations of cryptographic algorithms against power analysis has been studied.
Verificação formal de implementações em software de algoritmos criptográficos contra análise de potência é um assunto que tem sido pesquisado recentemente.
%
% Maggi et al.~\cite{maggi2013automated, Agosta:2013:CSC:2463209.2488833} propose a method based on data flow analysis, to be able to identify dependencies of each instruction on secret data. 
%
Por exemplo, Maggi et al.~\cite{maggi2013automated, Agosta2013} propuseram um método baseado em análise de fluxo de dados para identificar dependências entre as instruções executadas e dados secretos.
%
% The method is implemented into the LLVM compiler as a specialized pass that works at the intermediate representation level, thus it is architecture agnostic, supporting any of the architectures supported by LLVM. The tool automatically instantiates the essential masking countermeasures. 
%
O método é implementado em um compilador LLVM como uma passada especializada operando no nível de representação intermediária, portanto ela é agnóstica em arquitetura, suportando quaisquer das arquiteturas de computador suportadas por LLVM. A ferramenta automaticamente instancia contramedidas de masking à implementação.
%

% Most recently, Bayrak et al~\cite{BayrakRegazzoniNovo:2013, Bayrak2014} showed how to reduce the verification problem, in the case of power channels, into a set of Boolean satisfiability problems, which can be efficiently handled by current SAT solvers, and which overcome some of shortcomings of the information flow analysis approach. 

Mais recentemente, Bayrak et al~\cite{BayrakRegazzoniNovo2013, Bayrak2014} mostraram como reduzir o problema de verificação da resistência de uma implementação a vazamento por canais de potência à um conjunto de problemas SAT, os quais podem ser eficientemente tratados pelos resolvedores SAT atuais. Tal método a princípio endereça as limitações da abordagem baseada em análise de fluxo de informação.

% Their approach motivated the introduction of satisfiability module theories (SMT) solvers by Eldib et al~\cite{EldibWang2014, EldibWang2014_QMS, EldibWang2014_SMT, EldibWang2014_sc_sniffer} to tackle the problem in the case of power analysis. The latter authors also proposed methods for the automated application of countermeasures.
%
Resolvedores baseados em teorias do módulo de satisfabilidade (SMT) foram aplicados por Eldib et al~\cite{EldibWang2014, EldibWang2014_QMS, EldibWang2014_SMT, EldibWang2014_sc_sniffer} a este problema. Estes últimos também propuseram métodos para a aplicação automatizada de contramedidas.
